const fs = require('fs');
const path = require('path');

console.log('üîÑ Migration AUTOMATIQUE et DYNAMIQUE de TOUS les composants vers hooks...');

const srcDir = path.join(__dirname, '../src');
const prismaServicePath = path.join(__dirname, '../src/lib/prisma-service.ts');
const hooksDir = path.join(__dirname, '../src/hooks');
const excludeDirs = ['node_modules', '.git', '.next', 'dist', 'build', 'hooks', 'lib'];

// ====================================
// G√âN√âRATION DYNAMIQUE DU MAPPING 
// ====================================

function generateDynamicMapping() {
  console.log('üîç G√©n√©ration DYNAMIQUE du mapping depuis les fichiers existants...');
  
  const mapping = {};
  
  // 1. Analyser prisma-service.ts pour les mod√®les
  if (!fs.existsSync(prismaServicePath)) {
    console.error('‚ùå prisma-service.ts introuvable');
    return mapping;
  }
  
  const prismaContent = fs.readFileSync(prismaServicePath, 'utf-8');
  const models = new Set();
  
  // D√©tecter tous les mod√®les depuis getAll[Model]s
  const getAllRegex = /export async function getAll(\w+)s\(\)/g;
  let match;
  
  while ((match = getAllRegex.exec(prismaContent)) !== null) {
    models.add(match[1]);
  }
  
  console.log(`üìä ${models.size} mod√®les d√©tect√©s: ${Array.from(models).join(', ')}`);
  
  // 2. Analyser les hooks existants pour confirmer
  const availableHooks = new Set();
  if (fs.existsSync(hooksDir)) {
    const hookFiles = fs.readdirSync(hooksDir).filter(f => f.startsWith('use') && f.endsWith('.ts'));
    hookFiles.forEach(file => {
      const hookName = file.replace('.ts', '');
      availableHooks.add(hookName);
      
      // Extraire le mod√®le du nom du hook: useHosts -> Host
      const modelMatch = hookName.match(/^use(\w+)s?$/);
      if (modelMatch) {
        const modelName = modelMatch[1];
        if (modelName.endsWith('s')) {
          models.add(modelName.slice(0, -1)); // Enlever le 's'
        } else {
          models.add(modelName);
        }
      }
    });
  }
  
  console.log(`üìä ${availableHooks.size} hooks disponibles: ${Array.from(availableHooks).join(', ')}`);
  
  // 3. G√©n√©rer le mapping dynamiquement
  models.forEach(modelName => {
    const hookName = `use${modelName}s`;
    const pluralLower = modelName.toLowerCase() + 's';
    
    // V√©rifier si le hook existe
    const hookExists = availableHooks.has(hookName);
    if (!hookExists) {
      console.log(`‚ö†Ô∏è  Hook manquant: ${hookName} - sera ignor√©`);
      return;
    }
    
    // G√©n√©rer toutes les variations possibles de fonctions pour ce mod√®le
    const functionVariations = [
      // Patterns getAll
      `getAll${modelName}s`,
      `get${modelName}s`,
      `get${pluralLower}`,
      
      // Patterns getById
      `get${modelName}ById`,
      `get${modelName}ByEmail`, // Pour User
      `get${modelName}ByHostId`, // Pour relations
      
      // Patterns create/add
      `create${modelName}`,
      `add${modelName}`,
      `add${modelName}ToData`,
      
      // Patterns update
      `update${modelName}`,
      `update${modelName}InData`,
      
      // Patterns delete
      `delete${modelName}`,
      `delete${modelName}InData`,
      `remove${modelName}`,
      
      // Aliases courants
      ...(modelName === 'Host' ? ['addHost', 'getHosts'] : []),
      ...(modelName === 'User' ? ['addUser', 'getUsers'] : []),
      ...(modelName === 'Client' ? ['addClient', 'getClients'] : []),
      ...(modelName === 'Order' ? ['addOrder', 'getOrders'] : []),
      ...(modelName === 'Service' ? ['addService', 'getServices'] : []),
      ...(modelName === 'Reservation' ? ['addReservation', 'getReservations'] : []),
    ];
    
    // Mapper chaque variation √† la bonne propri√©t√© du hook
    functionVariations.forEach(funcName => {
      let property;
      
      // Logique dynamique pour d√©terminer la propri√©t√©
      if (funcName.includes('getAll') || funcName === `get${pluralLower}` || funcName === `get${modelName}s`) {
        property = pluralLower; // ex: hosts, users, clients
      } else if (funcName.includes('ById') || funcName.includes('ByEmail') || funcName.includes('ByHostId')) {
        property = `get${modelName}ById`;
      } else if (funcName.includes('create') || funcName.includes('add')) {
        property = `add${modelName}`;
      } else if (funcName.includes('update')) {
        property = `update${modelName}`;
      } else if (funcName.includes('delete') || funcName.includes('remove')) {
        property = `delete${modelName}`;
      } else {
        property = funcName; // fallback
      }
      
      mapping[funcName] = {
        hook: hookName,
        property: property,
        model: modelName
      };
    });
    
    console.log(`  ‚úÖ ${modelName}: ${functionVariations.length} fonctions mapp√©es vers ${hookName}`);
  });
  
  return mapping;
}

// ====================================
// ANALYSE ET TRANSFORMATION DES FICHIERS
// ====================================

function analyzeImports(content) {
  const imports = {
    prismaService: [],
    otherImports: []
  };
  
  // D√©tecter tous les imports depuis prisma-service
  const importPatterns = [
    /import\s*\{\s*([^}]+)\s*\}\s*from\s*['"]@\/lib\/prisma-service['"];?/g,
    /import\s*\{\s*([^}]+)\s*\}\s*from\s*['"][^'"]*prisma-service['"];?/g
  ];
  
  importPatterns.forEach(pattern => {
    const matches = [...content.matchAll(pattern)];
    matches.forEach(match => {
      const functions = match[1]
        .split(',')
        .map(f => f.trim().replace(/\s+as\s+\w+/g, '')) // Enlever les alias "as xxx"
        .filter(f => f.length > 0);
      imports.prismaService.push(...functions);
    });
  });
  
  return imports;
}

function generateHookUsages(usedFunctions, mapping) {
  const hookUsages = new Map();
  const hookImports = new Set();
  
  usedFunctions.forEach(func => {
    const mappingInfo = mapping[func];
    if (mappingInfo) {
      hookImports.add(mappingInfo.hook);
      
      if (!hookUsages.has(mappingInfo.hook)) {
        hookUsages.set(mappingInfo.hook, new Set());
      }
      hookUsages.get(mappingInfo.hook).add(mappingInfo.property);
    }
  });
  
  return { hookImports: Array.from(hookImports), hookUsages };
}

function transformFileContent(content, filePath, mapping) {
  let newContent = content;
  let hasChanges = false;
  
  const imports = analyzeImports(content);
  
  if (imports.prismaService.length === 0) {
    return { content: newContent, changed: false };
  }
  
  console.log(`  üîç ${path.relative(srcDir, filePath)}: ${imports.prismaService.length} fonctions Prisma d√©tect√©es`);
  
  const { hookImports, hookUsages } = generateHookUsages(imports.prismaService, mapping);
  
  if (hookImports.length === 0) {
    console.log(`  ‚è≠Ô∏è  Aucun hook disponible pour les fonctions utilis√©es`);
    return { content: newContent, changed: false };
  }
  
  // 1. Supprimer les imports prisma-service
  const prismaImportRegex = /import\s*\{\s*[^}]+\s*\}\s*from\s*['"][^'"]*prisma-service['"];?\n?/g;
  newContent = newContent.replace(prismaImportRegex, '');
  hasChanges = true;
  
  // 2. Ajouter "use client" si pas pr√©sent
  if (!newContent.includes('"use client"') && !newContent.includes("'use client'")) {
    newContent = '"use client";\n\n' + newContent;
  }
  
  // 3. Ajouter les imports de hooks
  const hookImportLine = `import { ${hookImports.join(', ')} } from '@/hooks';`;
  
  // Trouver o√π ins√©rer l'import
  const firstImportMatch = newContent.match(/^import\s/m);
  if (firstImportMatch) {
    const insertPosition = firstImportMatch.index;
    newContent = newContent.slice(0, insertPosition) + hookImportLine + '\n' + newContent.slice(insertPosition);
  } else {
    // Ins√©rer apr√®s "use client"
    const useClientMatch = newContent.match(/['"]use client['"];\n*/);
    if (useClientMatch) {
      const insertPosition = useClientMatch.index + useClientMatch[0].length;
      newContent = newContent.slice(0, insertPosition) + '\n' + hookImportLine + '\n' + newContent.slice(insertPosition);
    }
  }
  
  // 4. Ajouter les d√©clarations de hooks dans le composant
  hookImports.forEach(hookName => {
    const properties = Array.from(hookUsages.get(hookName));
    const hookDeclaration = `  const { ${properties.join(', ')} } = ${hookName}();`;
    
    // Trouver le d√©but du composant (function ou const)
    const componentRegex = /(export\s+(?:default\s+)?function\s+\w+|const\s+\w+\s*=\s*\([^)]*\)\s*=>|function\s+\w+\s*\([^)]*\))/;
    const componentMatch = newContent.match(componentRegex);
    
    if (componentMatch) {
      const insertAfter = componentMatch.index + componentMatch[0].length;
      const nextBraceIndex = newContent.indexOf('{', insertAfter);
      
      if (nextBraceIndex !== -1) {
        // V√©rifier si la d√©claration n'existe pas d√©j√†
        if (!newContent.includes(hookDeclaration)) {
          newContent = newContent.slice(0, nextBraceIndex + 1) + '\n' + hookDeclaration + '\n' + newContent.slice(nextBraceIndex + 1);
        }
      }
    }
  });
  
  // 5. Remplacer les appels de fonctions
  imports.prismaService.forEach(func => {
    const mappingInfo = mapping[func];
    if (mappingInfo) {
      // Remplacer les appels directs de fonction
      const functionCallRegex = new RegExp(`\\b${escapeRegExp(func)}\\s*\\(`, 'g');
      if (functionCallRegex.test(newContent)) {
        newContent = newContent.replace(functionCallRegex, `${mappingInfo.property}(`);
        hasChanges = true;
        console.log(`    üìù ${func} ‚Üí ${mappingInfo.property}`);
      }
    }
  });
  
  return { content: newContent, changed: hasChanges };
}

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ====================================
// TRAITEMENT R√âCURSIF DES R√âPERTOIRES
// ====================================

function shouldProcessFile(filePath) {
  const ext = path.extname(filePath);
  return ['.ts', '.tsx', '.js', '.jsx'].includes(ext);
}

function shouldSkipDirectory(dirName) {
  return excludeDirs.includes(dirName) || dirName.startsWith('.');
}

function processDirectory(dirPath, mapping) {
  let filesProcessed = 0;
  let filesChanged = 0;
  
  if (!fs.existsSync(dirPath)) {
    return { filesProcessed, filesChanged };
  }
  
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  
  entries.forEach(entry => {
    const fullPath = path.join(dirPath, entry.name);
    
    if (entry.isDirectory()) {
      if (!shouldSkipDirectory(entry.name)) {
        const result = processDirectory(fullPath, mapping);
        filesProcessed += result.filesProcessed;
        filesChanged += result.filesChanged;
      }
    } else if (entry.isFile() && shouldProcessFile(fullPath)) {
      try {
        const content = fs.readFileSync(fullPath, 'utf-8');
        
        // V√©rifier si le fichier contient des imports prisma-service
        if (!content.includes('prisma-service')) {
          return;
        }
        
        const { content: newContent, changed } = transformFileContent(content, fullPath, mapping);
        
        filesProcessed++;
        
        if (changed) {
          fs.writeFileSync(fullPath, newContent, 'utf-8');
          console.log(`  ‚úÖ ${path.relative(srcDir, fullPath)}`);
          filesChanged++;
        }
      } catch (error) {
        console.error(`  ‚ùå Erreur ${path.relative(srcDir, fullPath)}:`, error.message);
      }
    }
  });
  
  return { filesProcessed, filesChanged };
}

// ====================================
// EX√âCUTION PRINCIPALE
// ====================================

try {
  console.log('üîç G√©n√©ration du mapping dynamique...');
  const mapping = generateDynamicMapping();
  
  if (Object.keys(mapping).length === 0) {
    console.error('‚ùå Aucun mapping g√©n√©r√© - V√©rifiez prisma-service.ts et les hooks');
    process.exit(1);
  }
  
  console.log(`üìä ${Object.keys(mapping).length} fonctions mapp√©es dynamiquement`);
  
  // Afficher un √©chantillon du mapping pour debug
  console.log('\nüìã √âchantillon du mapping g√©n√©r√©:');
  Object.entries(mapping).slice(0, 10).forEach(([func, info]) => {
    console.log(`  ${func} ‚Üí ${info.hook}.${info.property}`);
  });
  
  const dirsToProcess = [
    path.join(srcDir, 'app'),
    path.join(srcDir, 'components'),
    path.join(srcDir, 'pages')
  ];
  
  let totalFilesProcessed = 0;
  let totalFilesChanged = 0;
  
  dirsToProcess.forEach(dir => {
    if (fs.existsSync(dir)) {
      console.log(`\nüìÅ Traitement: ${path.relative(srcDir, dir)}`);
      const result = processDirectory(dir, mapping);
      totalFilesProcessed += result.filesProcessed;
      totalFilesChanged += result.filesChanged;
      console.log(`  üìä ${result.filesChanged}/${result.filesProcessed} fichiers modifi√©s`);
    }
  });
  
  console.log('\n' + '='.repeat(60));
  console.log(`üéâ Migration DYNAMIQUE termin√©e !`);
  console.log(`üìä R√©sultats finaux:`);
  console.log(`   - ${totalFilesProcessed} fichiers analys√©s`);
  console.log(`   - ${totalFilesChanged} fichiers migr√©s automatiquement`);
  console.log(`   - ${Object.keys(mapping).length} fonctions mapp√©es dynamiquement`);
  console.log(`\n‚úÖ Migration 100% automatique et future-proof !`);
  
  if (totalFilesChanged > 0) {
    console.log(`\nüöÄ Actions effectu√©es automatiquement:`);
    console.log(`   ‚úì D√©tection automatique des mod√®les depuis prisma-service.ts`);
    console.log(`   ‚úì G√©n√©ration dynamique du mapping fonction ‚Üí hook`);
    console.log(`   ‚úì Remplacement automatique imports prisma-service ‚Üí hooks`);
    console.log(`   ‚úì Ajout automatique des d√©clarations de hooks`);
    console.log(`   ‚úì Transformation des appels de fonctions`);
    console.log(`   ‚úì Support automatique des futurs mod√®les !`);
  }
  
} catch (error) {
  console.error('‚ùå Erreur lors de la migration dynamique:', error.message);
  console.error('Stack:', error.stack);
  process.exit(1);
}
